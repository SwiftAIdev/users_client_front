/* tslint:disable */
/* eslint-disable */
/**
 * SwiftAI - User Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BearerResponse
 */
export interface BearerResponse {
    /**
     * 
     * @type {string}
     * @memberof BearerResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof BearerResponse
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface Detail
 */
export interface Detail {
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {Detail}
     * @memberof ErrorModel
     */
    'detail': Detail;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HealthCheckDetailsSchema
 */
export interface HealthCheckDetailsSchema {
    /**
     * 
     * @type {StatusDatabase}
     * @memberof HealthCheckDetailsSchema
     */
    'database': StatusDatabase;
    /**
     * 
     * @type {StatusRedis}
     * @memberof HealthCheckDetailsSchema
     */
    'redis': StatusRedis;
    /**
     * 
     * @type {string}
     * @memberof HealthCheckDetailsSchema
     */
    'uptime': string;
}


/**
 * 
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'status': string;
    /**
     * 
     * @type {HealthCheckDetailsSchema}
     * @memberof HealthCheckResponse
     */
    'details': HealthCheckDetailsSchema;
}
/**
 * 
 * @export
 * @interface InviteUserSchemaAdd
 */
export interface InviteUserSchemaAdd {
    /**
     * 
     * @type {string}
     * @memberof InviteUserSchemaAdd
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserSchemaAdd
     */
    'invite_code': string;
}
/**
 * 
 * @export
 * @interface PaginationRequestPermissionSchema
 */
export interface PaginationRequestPermissionSchema {
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestPermissionSchema
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestPermissionSchema
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestPermissionSchema
     */
    'total': number;
    /**
     * 
     * @type {Array<PermissionSchema>}
     * @memberof PaginationRequestPermissionSchema
     */
    'data': Array<PermissionSchema>;
}
/**
 * 
 * @export
 * @interface PaginationRequestRoleSchema
 */
export interface PaginationRequestRoleSchema {
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestRoleSchema
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestRoleSchema
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestRoleSchema
     */
    'total': number;
    /**
     * 
     * @type {Array<RoleSchema>}
     * @memberof PaginationRequestRoleSchema
     */
    'data': Array<RoleSchema>;
}
/**
 * 
 * @export
 * @interface PaginationRequestUserSchemaBase
 */
export interface PaginationRequestUserSchemaBase {
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestUserSchemaBase
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestUserSchemaBase
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationRequestUserSchemaBase
     */
    'total': number;
    /**
     * 
     * @type {Array<UserSchemaBase>}
     * @memberof PaginationRequestUserSchemaBase
     */
    'data': Array<UserSchemaBase>;
}
/**
 * 
 * @export
 * @interface PermissionSchema
 */
export interface PermissionSchema {
    /**
     * ID пользователя в системе
     * @type {number}
     * @memberof PermissionSchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionSchema
     */
    'created_at'?: string;
    /**
     * Дата последнего обновления
     * @type {string}
     * @memberof PermissionSchema
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionSchema
     */
    'is_delete'?: boolean;
    /**
     * Название разрешения
     * @type {string}
     * @memberof PermissionSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PermissionSchemaAdd
 */
export interface PermissionSchemaAdd {
    /**
     * 
     * @type {string}
     * @memberof PermissionSchemaAdd
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResultRequest
 */
export interface ResultRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @interface RoleSchema
 */
export interface RoleSchema {
    /**
     * ID пользователя в системе
     * @type {number}
     * @memberof RoleSchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleSchema
     */
    'created_at'?: string;
    /**
     * Дата последнего обновления
     * @type {string}
     * @memberof RoleSchema
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSchema
     */
    'is_delete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RoleSchema
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<PermissionSchema>}
     * @memberof RoleSchema
     */
    'permissions': Array<PermissionSchema>;
}
/**
 * 
 * @export
 * @interface RoleSchemaAdd
 */
export interface RoleSchemaAdd {
    /**
     * 
     * @type {string}
     * @memberof RoleSchemaAdd
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RoleSchemaAddPermission
 */
export interface RoleSchemaAddPermission {
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleSchemaAddPermission
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceErrorPydantic
 */
export interface ServiceErrorPydantic {
    /**
     * 
     * @type {string}
     * @memberof ServiceErrorPydantic
     */
    'message': string;
    /**
     * 
     * @type {TypeErrorEnum}
     * @memberof ServiceErrorPydantic
     */
    'type': TypeErrorEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StatusDatabase = {
    Connected: 'connected',
    Disconnected: 'disconnected'
} as const;

export type StatusDatabase = typeof StatusDatabase[keyof typeof StatusDatabase];


/**
 * 
 * @export
 * @enum {string}
 */

export const StatusRedis = {
    Available: 'available',
    Unavailable: 'unavailable'
} as const;

export type StatusRedis = typeof StatusRedis[keyof typeof StatusRedis];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypeErrorEnum = {
    UserError: 'user error',
    Unauthorized: 'unauthorized',
    Forbidden: 'forbidden',
    NotFound: 'not found',
    Conflict: 'conflict',
    ServerError: 'server error'
} as const;

export type TypeErrorEnum = typeof TypeErrorEnum[keyof typeof TypeErrorEnum];


/**
 * 
 * @export
 * @interface UserSchemaAdd
 */
export interface UserSchemaAdd {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaAdd
     */
    'third_party_ID': string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaAdd
     */
    'domain': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaAdd
     */
    'is_integrator'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSchemaBase
 */
export interface UserSchemaBase {
    /**
     * ID пользователя в системе
     * @type {number}
     * @memberof UserSchemaBase
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'created_at'?: string;
    /**
     * Дата последнего обновления
     * @type {string}
     * @memberof UserSchemaBase
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaBase
     */
    'is_delete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'surname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'domain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'invite_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaBase
     */
    'third_party_ID': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaBase
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaBase
     */
    'is_integrator'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaBase
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSchemaBase
     */
    'is_verified'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSchemaChangeEmail
 */
export interface UserSchemaChangeEmail {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaChangeEmail
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UserSchemaChangePassword
 */
export interface UserSchemaChangePassword {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaChangePassword
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaChangePassword
     */
    'new_password': string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaChangePassword
     */
    'repeat_password': string;
}
/**
 * 
 * @export
 * @interface UserSchemaLogin
 */
export interface UserSchemaLogin {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaLogin
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaLogin
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserSchemaRegister
 */
export interface UserSchemaRegister {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaRegister
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaRegister
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserSchemaUpdate
 */
export interface UserSchemaUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserSchemaUpdate
     */
    'surname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSchemaUpdate
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth:Users.Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersLogin: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authUsersLogin', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authUsersLogin', 'password', password)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Auth:Users.Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth:Users.Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersLogin(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BearerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUsersLogin(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authUsersLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Auth:Users.Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUsersLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authUsersLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Auth:Users.Login
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersLogin(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BearerResponse> {
            return localVarFp.authUsersLogin(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Auth:Users.Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersLogout(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authUsersLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Auth:Users.Login
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersLogin(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authUsersLogin(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Auth:Users.Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authUsersLogout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitedUserApi - axios parameter creator
 * @export
 */
export const InvitedUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite By Integrator Id
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet: async (userId: string, integratorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet', 'userId', userId)
            // verify required parameter 'integratorId' is not null or undefined
            assertParamExists('checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet', 'integratorId', integratorId)
            const localVarPath = `/users/{user_id}/check-invite/{integrator_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"integrator_id"}}`, encodeURIComponent(String(integratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInviteUsersUserIdCheckInviteGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkInviteUsersUserIdCheckInviteGet', 'userId', userId)
            const localVarPath = `/users/{user_id}/check-invite`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get integrator by user ID.  This endpoint retrieves the integrator associated with a specific user.
         * @summary Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegratorUsersUserIdIntegratorGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getIntegratorUsersUserIdIntegratorGet', 'userId', userId)
            const localVarPath = `/users/{user_id}/integrator`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get invited users.  This endpoint retrieves a paginated list of users invited by a specific user.
         * @summary Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitedUsersUsersIntegratorIdInvitedGet: async (integratorId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integratorId' is not null or undefined
            assertParamExists('getInvitedUsersUsersIntegratorIdInvitedGet', 'integratorId', integratorId)
            const localVarPath = `/users/{integrator_id}/invited`
                .replace(`{${"integrator_id"}}`, encodeURIComponent(String(integratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user.  This endpoint allows inviting a new user.
         * @summary Invite User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserUsersInvitePost: async (inviteUserSchemaAdd: InviteUserSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteUserSchemaAdd' is not null or undefined
            assertParamExists('inviteUserUsersInvitePost', 'inviteUserSchemaAdd', inviteUserSchemaAdd)
            const localVarPath = `/users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Add Invited User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddInvitedUser: async (inviteUserSchemaAdd: InviteUserSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteUserSchemaAdd' is not null or undefined
            assertParamExists('v1AddInvitedUser', 'inviteUserSchemaAdd', inviteUserSchemaAdd)
            const localVarPath = `/v1/users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Check Invited User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckInvitedUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1CheckInvitedUser', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}/check-invite`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Check Invited User By Integrator
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckInvitedUserByIntegrator: async (userId: string, integratorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1CheckInvitedUserByIntegrator', 'userId', userId)
            // verify required parameter 'integratorId' is not null or undefined
            assertParamExists('v1CheckInvitedUserByIntegrator', 'integratorId', integratorId)
            const localVarPath = `/v1/users/{user_id}/check-invite/{integrator_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"integrator_id"}}`, encodeURIComponent(String(integratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetIntegrator: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1GetIntegrator', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}/integrator`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetInvitedUsers: async (integratorId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integratorId' is not null or undefined
            assertParamExists('v1GetInvitedUsers', 'integratorId', integratorId)
            const localVarPath = `/v1/users/{integrator_id}/invited`
                .replace(`{${"integrator_id"}}`, encodeURIComponent(String(integratorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitedUserApi - functional programming interface
 * @export
 */
export const InvitedUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitedUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite By Integrator Id
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId: string, integratorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId, integratorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInviteUsersUserIdCheckInviteGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInviteUsersUserIdCheckInviteGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.checkInviteUsersUserIdCheckInviteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get integrator by user ID.  This endpoint retrieves the integrator associated with a specific user.
         * @summary Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegratorUsersUserIdIntegratorGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegratorUsersUserIdIntegratorGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.getIntegratorUsersUserIdIntegratorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get invited users.  This endpoint retrieves a paginated list of users invited by a specific user.
         * @summary Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitedUsersUsersIntegratorIdInvitedGet(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestUserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitedUsersUsersIntegratorIdInvitedGet(integratorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.getInvitedUsersUsersIntegratorIdInvitedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a new user.  This endpoint allows inviting a new user.
         * @summary Invite User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserUsersInvitePost(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserUsersInvitePost(inviteUserSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.inviteUserUsersInvitePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Add Invited User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AddInvitedUser(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AddInvitedUser(inviteUserSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.v1AddInvitedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Check Invited User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckInvitedUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckInvitedUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.v1CheckInvitedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Check Invited User By Integrator
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckInvitedUserByIntegrator(userId: string, integratorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckInvitedUserByIntegrator(userId, integratorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.v1CheckInvitedUserByIntegrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetIntegrator(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetIntegrator(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.v1GetIntegrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetInvitedUsers(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestUserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetInvitedUsers(integratorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitedUserApi.v1GetInvitedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitedUserApi - factory interface
 * @export
 */
export const InvitedUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitedUserApiFp(configuration)
    return {
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite By Integrator Id
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId: string, integratorId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId, integratorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
         * @summary Check Invite
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInviteUsersUserIdCheckInviteGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.checkInviteUsersUserIdCheckInviteGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get integrator by user ID.  This endpoint retrieves the integrator associated with a specific user.
         * @summary Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegratorUsersUserIdIntegratorGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.getIntegratorUsersUserIdIntegratorGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get invited users.  This endpoint retrieves a paginated list of users invited by a specific user.
         * @summary Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitedUsersUsersIntegratorIdInvitedGet(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestUserSchemaBase> {
            return localVarFp.getInvitedUsersUsersIntegratorIdInvitedGet(integratorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user.  This endpoint allows inviting a new user.
         * @summary Invite User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserUsersInvitePost(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.inviteUserUsersInvitePost(inviteUserSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Add Invited User
         * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddInvitedUser(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.v1AddInvitedUser(inviteUserSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Check Invited User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckInvitedUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.v1CheckInvitedUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Check Invited User By Integrator
         * @param {string} userId 
         * @param {string} integratorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckInvitedUserByIntegrator(userId: string, integratorId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.v1CheckInvitedUserByIntegrator(userId, integratorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get Integrator
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetIntegrator(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1GetIntegrator(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get Invited Users
         * @param {string} integratorId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetInvitedUsers(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestUserSchemaBase> {
            return localVarFp.v1GetInvitedUsers(integratorId, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitedUserApi - object-oriented interface
 * @export
 * @class InvitedUserApi
 * @extends {BaseAPI}
 */
export class InvitedUserApi extends BaseAPI {
    /**
     * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
     * @summary Check Invite By Integrator Id
     * @param {string} userId 
     * @param {string} integratorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId: string, integratorId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).checkInviteByIntegratorIDUsersUserIdCheckInviteIntegratorIdGet(userId, integratorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check user invitation.  This endpoint verifies if a user was invited by a specific integrator.
     * @summary Check Invite
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public checkInviteUsersUserIdCheckInviteGet(userId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).checkInviteUsersUserIdCheckInviteGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get integrator by user ID.  This endpoint retrieves the integrator associated with a specific user.
     * @summary Get Integrator
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public getIntegratorUsersUserIdIntegratorGet(userId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).getIntegratorUsersUserIdIntegratorGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get invited users.  This endpoint retrieves a paginated list of users invited by a specific user.
     * @summary Get Invited Users
     * @param {string} integratorId 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public getInvitedUsersUsersIntegratorIdInvitedGet(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).getInvitedUsersUsersIntegratorIdInvitedGet(integratorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user.  This endpoint allows inviting a new user.
     * @summary Invite User
     * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public inviteUserUsersInvitePost(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).inviteUserUsersInvitePost(inviteUserSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Add Invited User
     * @param {InviteUserSchemaAdd} inviteUserSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public v1AddInvitedUser(inviteUserSchemaAdd: InviteUserSchemaAdd, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).v1AddInvitedUser(inviteUserSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Check Invited User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public v1CheckInvitedUser(userId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).v1CheckInvitedUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Check Invited User By Integrator
     * @param {string} userId 
     * @param {string} integratorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public v1CheckInvitedUserByIntegrator(userId: string, integratorId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).v1CheckInvitedUserByIntegrator(userId, integratorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get Integrator
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public v1GetIntegrator(userId: string, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).v1GetIntegrator(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get Invited Users
     * @param {string} integratorId 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitedUserApi
     */
    public v1GetInvitedUsers(integratorId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return InvitedUserApiFp(this.configuration).v1GetInvitedUsers(integratorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionApi - axios parameter creator
 * @export
 */
export const PermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new permission.  This endpoint allows for the creation of a new permission.
         * @summary Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermissionPermissionsPost: async (permissionSchemaAdd: PermissionSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionSchemaAdd' is not null or undefined
            assertParamExists('createPermissionPermissionsPost', 'permissionSchemaAdd', permissionSchemaAdd)
            const localVarPath = `/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a permission by ID.  This endpoint deletes a permission by its unique ID.
         * @summary Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionPermissionsPermissionIdDelete: async (permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('deletePermissionPermissionsPermissionIdDelete', 'permissionId', permissionId)
            const localVarPath = `/permissions/{permission_id}`
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a permission by ID.  This endpoint retrieves a permission by its unique ID.
         * @summary Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionByIDPermissionsPermissionIdGet: async (permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getPermissionByIDPermissionsPermissionIdGet', 'permissionId', permissionId)
            const localVarPath = `/permissions/{permission_id}`
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of permissions.  This endpoint retrieves a paginated list of permissions based on provided filters.
         * @summary Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsPermissionsGet: async (page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (isDeleteIn !== undefined) {
                localVarQueryParameter['is_delete__in'] = isDeleteIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Permissions:Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreatePermission: async (permissionSchemaAdd: PermissionSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionSchemaAdd' is not null or undefined
            assertParamExists('v1CreatePermission', 'permissionSchemaAdd', permissionSchemaAdd)
            const localVarPath = `/v1/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Permissions:Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeletePermission: async (permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('v1DeletePermission', 'permissionId', permissionId)
            const localVarPath = `/v1/permissions/{permission_id}`
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Permissions:Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPermissionById: async (permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('v1GetPermissionById', 'permissionId', permissionId)
            const localVarPath = `/v1/permissions/{permission_id}`
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Permissions:Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPermissions: async (page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (isDeleteIn !== undefined) {
                localVarQueryParameter['is_delete__in'] = isDeleteIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new permission.  This endpoint allows for the creation of a new permission.
         * @summary Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermissionPermissionsPost(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermissionPermissionsPost(permissionSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.createPermissionPermissionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a permission by ID.  This endpoint deletes a permission by its unique ID.
         * @summary Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionPermissionsPermissionIdDelete(permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionPermissionsPermissionIdDelete(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.deletePermissionPermissionsPermissionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a permission by ID.  This endpoint retrieves a permission by its unique ID.
         * @summary Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionByIDPermissionsPermissionIdGet(permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionByIDPermissionsPermissionIdGet(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.getPermissionByIDPermissionsPermissionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a paginated list of permissions.  This endpoint retrieves a paginated list of permissions based on provided filters.
         * @summary Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionsPermissionsGet(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestPermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionsPermissionsGet(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.getPermissionsPermissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Permissions:Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreatePermission(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreatePermission(permissionSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.v1CreatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Permissions:Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeletePermission(permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeletePermission(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.v1DeletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Permissions:Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetPermissionById(permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetPermissionById(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.v1GetPermissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Permissions:Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetPermissions(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestPermissionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetPermissions(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.v1GetPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionApiFp(configuration)
    return {
        /**
         * Create a new permission.  This endpoint allows for the creation of a new permission.
         * @summary Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermissionPermissionsPost(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<PermissionSchema> {
            return localVarFp.createPermissionPermissionsPost(permissionSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a permission by ID.  This endpoint deletes a permission by its unique ID.
         * @summary Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionPermissionsPermissionIdDelete(permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deletePermissionPermissionsPermissionIdDelete(permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a permission by ID.  This endpoint retrieves a permission by its unique ID.
         * @summary Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionByIDPermissionsPermissionIdGet(permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<PermissionSchema> {
            return localVarFp.getPermissionByIDPermissionsPermissionIdGet(permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of permissions.  This endpoint retrieves a paginated list of permissions based on provided filters.
         * @summary Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsPermissionsGet(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestPermissionSchema> {
            return localVarFp.getPermissionsPermissionsGet(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Permissions:Create Permission
         * @param {PermissionSchemaAdd} permissionSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreatePermission(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<PermissionSchema> {
            return localVarFp.v1CreatePermission(permissionSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Permissions:Delete Permission
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeletePermission(permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.v1DeletePermission(permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Permissions:Get Permission By Id
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPermissionById(permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<PermissionSchema> {
            return localVarFp.v1GetPermissionById(permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Permissions:Get Permissions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPermissions(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestPermissionSchema> {
            return localVarFp.v1GetPermissions(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * Create a new permission.  This endpoint allows for the creation of a new permission.
     * @summary Create Permission
     * @param {PermissionSchemaAdd} permissionSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public createPermissionPermissionsPost(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).createPermissionPermissionsPost(permissionSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a permission by ID.  This endpoint deletes a permission by its unique ID.
     * @summary Delete Permission
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public deletePermissionPermissionsPermissionIdDelete(permissionId: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).deletePermissionPermissionsPermissionIdDelete(permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a permission by ID.  This endpoint retrieves a permission by its unique ID.
     * @summary Get Permission By Id
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public getPermissionByIDPermissionsPermissionIdGet(permissionId: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).getPermissionByIDPermissionsPermissionIdGet(permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of permissions.  This endpoint retrieves a paginated list of permissions based on provided filters.
     * @summary Get Permissions
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string | null} [isDeleteIn] 
     * @param {string | null} [name] 
     * @param {string | null} [nameIn] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {string | null} [idNeq] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public getPermissionsPermissionsGet(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).getPermissionsPermissionsGet(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Permissions:Create Permission
     * @param {PermissionSchemaAdd} permissionSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public v1CreatePermission(permissionSchemaAdd: PermissionSchemaAdd, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).v1CreatePermission(permissionSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Permissions:Delete Permission
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public v1DeletePermission(permissionId: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).v1DeletePermission(permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Permissions:Get Permission By Id
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public v1GetPermissionById(permissionId: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).v1GetPermissionById(permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Permissions:Get Permissions
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string | null} [isDeleteIn] 
     * @param {string | null} [name] 
     * @param {string | null} [nameIn] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {string | null} [idNeq] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public v1GetPermissions(page?: number, size?: number, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).v1GetPermissions(page, size, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost', 'permissionId', permissionId)
            const localVarPath = `/roles/{role_id}/permissions/{permission_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permissions To Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsToRoleRolesRoleIdPermissionsPost: async (roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addPermissionsToRoleRolesRoleIdPermissionsPost', 'roleId', roleId)
            // verify required parameter 'roleSchemaAddPermission' is not null or undefined
            assertParamExists('addPermissionsToRoleRolesRoleIdPermissionsPost', 'roleSchemaAddPermission', roleSchemaAddPermission)
            const localVarPath = `/roles/{role_id}/permissions`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleSchemaAddPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new role.  This endpoint allows for the creation of a new role.
         * @summary Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleRolesPost: async (roleSchemaAdd: RoleSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleSchemaAdd' is not null or undefined
            assertParamExists('createRoleRolesPost', 'roleSchemaAdd', roleSchemaAdd)
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role by ID.  This endpoint deletes a role by its unique ID.
         * @summary Delete Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleRolesRoleIdDelete: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRoleRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a role by ID.  This endpoint retrieves a role by its unique ID.
         * @summary Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByIDRolesRoleIdGet: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleByIDRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of roles.  This endpoint retrieves a paginated list of roles based on provided filters.
         * @summary Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesRolesGet: async (page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (isDelete !== undefined) {
                localVarQueryParameter['is_delete'] = isDelete;
            }

            if (isDeleteIn !== undefined) {
                localVarQueryParameter['is_delete__in'] = isDeleteIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Remove Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete', 'permissionId', permissionId)
            const localVarPath = `/roles/{role_id}/permissions/{permission_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Add Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddPermissionByRole: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('v1AddPermissionByRole', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('v1AddPermissionByRole', 'permissionId', permissionId)
            const localVarPath = `/v1/roles/{role_id}/permissions/{permission_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Add Permissions By Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddPermissionsByRole: async (roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('v1AddPermissionsByRole', 'roleId', roleId)
            // verify required parameter 'roleSchemaAddPermission' is not null or undefined
            assertParamExists('v1AddPermissionsByRole', 'roleSchemaAddPermission', roleSchemaAddPermission)
            const localVarPath = `/v1/roles/{role_id}/permissions`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleSchemaAddPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateRole: async (roleSchemaAdd: RoleSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleSchemaAdd' is not null or undefined
            assertParamExists('v1CreateRole', 'roleSchemaAdd', roleSchemaAdd)
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoleById: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('v1GetRoleById', 'roleId', roleId)
            const localVarPath = `/v1/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoles: async (page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (isDelete !== undefined) {
                localVarQueryParameter['is_delete'] = isDelete;
            }

            if (isDeleteIn !== undefined) {
                localVarQueryParameter['is_delete__in'] = isDeleteIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Remove Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RemovePermissionByRole: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('v1RemovePermissionByRole', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('v1RemovePermissionByRole', 'permissionId', permissionId)
            const localVarPath = `/v1/roles/{role_id}/permissions/{permission_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roles:Remove Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RemoveRole: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('v1RemoveRole', 'roleId', roleId)
            const localVarPath = `/v1/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permissions To Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionsToRoleRolesRoleIdPermissionsPost(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionsToRoleRolesRoleIdPermissionsPost(roleId, roleSchemaAddPermission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.addPermissionsToRoleRolesRoleIdPermissionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new role.  This endpoint allows for the creation of a new role.
         * @summary Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleRolesPost(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleRolesPost(roleSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRoleRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a role by ID.  This endpoint deletes a role by its unique ID.
         * @summary Delete Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleRolesRoleIdDelete(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRoleRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a role by ID.  This endpoint retrieves a role by its unique ID.
         * @summary Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleByIDRolesRoleIdGet(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleByIDRolesRoleIdGet(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRoleByIDRolesRoleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a paginated list of roles.  This endpoint retrieves a paginated list of roles based on provided filters.
         * @summary Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesRolesGet(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestRoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesRolesGet(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRolesRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Remove Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Add Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AddPermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AddPermissionByRole(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1AddPermissionByRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Add Permissions By Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AddPermissionsByRole(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AddPermissionsByRole(roleId, roleSchemaAddPermission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1AddPermissionsByRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateRole(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateRole(roleSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1CreateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetRoleById(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetRoleById(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1GetRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetRoles(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestRoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetRoles(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1GetRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Remove Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RemovePermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RemovePermissionByRole(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1RemovePermissionByRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Roles:Remove Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RemoveRole(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RemoveRole(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.v1RemoveRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Add Permissions To Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsToRoleRolesRoleIdPermissionsPost(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.addPermissionsToRoleRolesRoleIdPermissionsPost(roleId, roleSchemaAddPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new role.  This endpoint allows for the creation of a new role.
         * @summary Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleRolesPost(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.createRoleRolesPost(roleSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role by ID.  This endpoint deletes a role by its unique ID.
         * @summary Delete Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.deleteRoleRolesRoleIdDelete(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a role by ID.  This endpoint retrieves a role by its unique ID.
         * @summary Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByIDRolesRoleIdGet(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.getRoleByIDRolesRoleIdGet(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of roles.  This endpoint retrieves a paginated list of roles based on provided filters.
         * @summary Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesRolesGet(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestRoleSchema> {
            return localVarFp.getRolesRolesGet(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
         * @summary Remove Permission To Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Add Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddPermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1AddPermissionByRole(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Add Permissions By Role
         * @param {number} roleId 
         * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AddPermissionsByRole(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1AddPermissionsByRole(roleId, roleSchemaAddPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Create Role
         * @param {RoleSchemaAdd} roleSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateRole(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1CreateRole(roleSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Get Role By Id
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoleById(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1GetRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Get Roles
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {boolean | null} [isDelete] 
         * @param {string | null} [isDeleteIn] 
         * @param {string | null} [name] 
         * @param {string | null} [nameIn] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {string | null} [idNeq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoles(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestRoleSchema> {
            return localVarFp.v1GetRoles(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Remove Permission By Role
         * @param {number} roleId 
         * @param {number} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RemovePermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1RemovePermissionByRole(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roles:Remove Role
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RemoveRole(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.v1RemoveRole(roleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
     * @summary Add Permission To Role
     * @param {number} roleId 
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).addPermissionToRoleRolesRoleIdPermissionsPermissionIdPost(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
     * @summary Add Permissions To Role
     * @param {number} roleId 
     * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addPermissionsToRoleRolesRoleIdPermissionsPost(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).addPermissionsToRoleRolesRoleIdPermissionsPost(roleId, roleSchemaAddPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new role.  This endpoint allows for the creation of a new role.
     * @summary Create Role
     * @param {RoleSchemaAdd} roleSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRoleRolesPost(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRoleRolesPost(roleSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role by ID.  This endpoint deletes a role by its unique ID.
     * @summary Delete Role
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRoleRolesRoleIdDelete(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a role by ID.  This endpoint retrieves a role by its unique ID.
     * @summary Get Role By Id
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleByIDRolesRoleIdGet(roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleByIDRolesRoleIdGet(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of roles.  This endpoint retrieves a paginated list of roles based on provided filters.
     * @summary Get Roles
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {boolean | null} [isDelete] 
     * @param {string | null} [isDeleteIn] 
     * @param {string | null} [name] 
     * @param {string | null} [nameIn] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {string | null} [idNeq] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRolesRolesGet(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRolesRolesGet(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a permission to a role by ID.  This endpoint allows adding a permission to an existing role.
     * @summary Remove Permission To Role
     * @param {number} roleId 
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).removePermissionToRoleRolesRoleIdPermissionsPermissionIdDelete(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Add Permission By Role
     * @param {number} roleId 
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1AddPermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1AddPermissionByRole(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Add Permissions By Role
     * @param {number} roleId 
     * @param {RoleSchemaAddPermission} roleSchemaAddPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1AddPermissionsByRole(roleId: number, roleSchemaAddPermission: RoleSchemaAddPermission, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1AddPermissionsByRole(roleId, roleSchemaAddPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Create Role
     * @param {RoleSchemaAdd} roleSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1CreateRole(roleSchemaAdd: RoleSchemaAdd, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1CreateRole(roleSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Get Role By Id
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1GetRoleById(roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1GetRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Get Roles
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {boolean | null} [isDelete] 
     * @param {string | null} [isDeleteIn] 
     * @param {string | null} [name] 
     * @param {string | null} [nameIn] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {string | null} [idNeq] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1GetRoles(page?: number, size?: number, isDelete?: boolean | null, isDeleteIn?: string | null, name?: string | null, nameIn?: string | null, id?: number | null, idIn?: string | null, idNeq?: string | null, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1GetRoles(page, size, isDelete, isDeleteIn, name, nameIn, id, idIn, idNeq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Remove Permission By Role
     * @param {number} roleId 
     * @param {number} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1RemovePermissionByRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1RemovePermissionByRole(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Roles:Remove Role
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public v1RemoveRole(roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).v1RemoveRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change a user\'s email by ID.  This endpoint allows changing the email of an existing user.
         * @summary Change User Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserEmailUsersUserIdChangeEmailPost: async (userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeUserEmailUsersUserIdChangeEmailPost', 'userId', userId)
            // verify required parameter 'userSchemaChangeEmail' is not null or undefined
            assertParamExists('changeUserEmailUsersUserIdChangeEmailPost', 'userSchemaChangeEmail', userSchemaChangeEmail)
            const localVarPath = `/users/{user_id}/change_email`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaChangeEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a user\'s password by ID.  This endpoint allows changing the password of an existing user.
         * @summary Change User Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPasswordUsersUserIdChangePasswordPost: async (userId: string, userSchemaChangePassword: UserSchemaChangePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeUserPasswordUsersUserIdChangePasswordPost', 'userId', userId)
            // verify required parameter 'userSchemaChangePassword' is not null or undefined
            assertParamExists('changeUserPasswordUsersUserIdChangePasswordPost', 'userSchemaChangePassword', userSchemaChangePassword)
            const localVarPath = `/users/{user_id}/change_password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaChangePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.  This endpoint allows for the creation of a new user.
         * @summary Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost: async (userSchemaAdd: UserSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSchemaAdd' is not null or undefined
            assertParamExists('createUserUsersPost', 'userSchemaAdd', userSchemaAdd)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a user by ID.  This endpoint retrieves a user by their unique ID.
         * @summary Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIDUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserByIDUsersUserIdGet', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of users.  This endpoint retrieves a paginated list of users based on provided filters.
         * @summary Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsersGet: async (page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (surname !== undefined) {
                localVarQueryParameter['surname'] = surname;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailNot !== undefined) {
                localVarQueryParameter['email__not'] = emailNot;
            }

            if (thirdPartyID !== undefined) {
                localVarQueryParameter['third_party_ID'] = thirdPartyID;
            }

            if (inviteCode !== undefined) {
                localVarQueryParameter['invite_code'] = inviteCode;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log in a user.  This endpoint allows a user to log in with the provided credentials.
         * @summary Login User
         * @param {UserSchemaLogin} userSchemaLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUserUsersLoginPost: async (userSchemaLogin: UserSchemaLogin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSchemaLogin' is not null or undefined
            assertParamExists('loginUserUsersLoginPost', 'userSchemaLogin', userSchemaLogin)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a user.  This endpoint registers a new user with the provided information.
         * @summary Register User
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUserUsersUserIdRegisterPost: async (userId: string, userSchemaRegister: UserSchemaRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('registerUserUsersUserIdRegisterPost', 'userId', userId)
            // verify required parameter 'userSchemaRegister' is not null or undefined
            assertParamExists('registerUserUsersUserIdRegisterPost', 'userSchemaRegister', userSchemaRegister)
            const localVarPath = `/users/{user_id}/register`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user by ID.  This endpoint updates the details of an existing user.
         * @summary Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsersUserIdPut: async (userId: string, userSchemaUpdate: UserSchemaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserUsersUserIdPut', 'userId', userId)
            // verify required parameter 'userSchemaUpdate' is not null or undefined
            assertParamExists('updateUserUsersUserIdPut', 'userSchemaUpdate', userSchemaUpdate)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Change Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChangeEmail: async (userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1ChangeEmail', 'userId', userId)
            // verify required parameter 'userSchemaChangeEmail' is not null or undefined
            assertParamExists('v1ChangeEmail', 'userSchemaChangeEmail', userSchemaChangeEmail)
            const localVarPath = `/v1/users/{user_id}/change_email`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaChangeEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Change Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChangePassword: async (userId: string, userSchemaChangePassword: UserSchemaChangePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1ChangePassword', 'userId', userId)
            // verify required parameter 'userSchemaChangePassword' is not null or undefined
            assertParamExists('v1ChangePassword', 'userSchemaChangePassword', userSchemaChangePassword)
            const localVarPath = `/v1/users/{user_id}/change_password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaChangePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Check Register
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckRegister: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1CheckRegister', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}/check_register`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateUser: async (userSchemaAdd: UserSchemaAdd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSchemaAdd' is not null or undefined
            assertParamExists('v1CreateUser', 'userSchemaAdd', userSchemaAdd)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get Role By User Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoleByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1GetRoleByUserId', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}/role`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1GetUserById', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUsers: async (page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (surname !== undefined) {
                localVarQueryParameter['surname'] = surname;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailNot !== undefined) {
                localVarQueryParameter['email__not'] = emailNot;
            }

            if (thirdPartyID !== undefined) {
                localVarQueryParameter['third_party_ID'] = thirdPartyID;
            }

            if (inviteCode !== undefined) {
                localVarQueryParameter['invite_code'] = inviteCode;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id__neq'] = idNeq;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Register
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Register: async (userId: string, userSchemaRegister: UserSchemaRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1Register', 'userId', userId)
            // verify required parameter 'userSchemaRegister' is not null or undefined
            assertParamExists('v1Register', 'userSchemaRegister', userSchemaRegister)
            const localVarPath = `/v1/users/{user_id}/register`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users:Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateUser: async (userId: string, userSchemaUpdate: UserSchemaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1UpdateUser', 'userId', userId)
            // verify required parameter 'userSchemaUpdate' is not null or undefined
            assertParamExists('v1UpdateUser', 'userSchemaUpdate', userSchemaUpdate)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSchemaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Change a user\'s email by ID.  This endpoint allows changing the email of an existing user.
         * @summary Change User Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserEmailUsersUserIdChangeEmailPost(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserEmailUsersUserIdChangeEmailPost(userId, userSchemaChangeEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeUserEmailUsersUserIdChangeEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change a user\'s password by ID.  This endpoint allows changing the password of an existing user.
         * @summary Change User Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPasswordUsersUserIdChangePasswordPost(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPasswordUsersUserIdChangePasswordPost(userId, userSchemaChangePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeUserPasswordUsersUserIdChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user.  This endpoint allows for the creation of a new user.
         * @summary Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserUsersPost(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserUsersPost(userSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUserUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a user by ID.  This endpoint retrieves a user by their unique ID.
         * @summary Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIDUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIDUsersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserByIDUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a paginated list of users.  This endpoint retrieves a paginated list of users based on provided filters.
         * @summary Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsersGet(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestUserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsersGet(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log in a user.  This endpoint allows a user to log in with the provided credentials.
         * @summary Login User
         * @param {UserSchemaLogin} userSchemaLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUserUsersLoginPost(userSchemaLogin: UserSchemaLogin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUserUsersLoginPost(userSchemaLogin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.loginUserUsersLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a user.  This endpoint registers a new user with the provided information.
         * @summary Register User
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUserUsersUserIdRegisterPost(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUserUsersUserIdRegisterPost(userId, userSchemaRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.registerUserUsersUserIdRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user by ID.  This endpoint updates the details of an existing user.
         * @summary Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserUsersUserIdPut(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserUsersUserIdPut(userId, userSchemaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserUsersUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Change Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChangeEmail(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChangeEmail(userId, userSchemaChangeEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1ChangeEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Change Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChangePassword(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChangePassword(userId, userSchemaChangePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1ChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Check Register
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckRegister(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckRegister(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1CheckRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateUser(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateUser(userSchemaAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1CreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1GetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get Role By User Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetRoleByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetRoleByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1GetRoleByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1GetUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetUsers(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationRequestUserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetUsers(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1GetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Register
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Register(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1Register(userId, userSchemaRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1Register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users:Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateUser(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchemaBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateUser(userId, userSchemaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1UpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Change a user\'s email by ID.  This endpoint allows changing the email of an existing user.
         * @summary Change User Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserEmailUsersUserIdChangeEmailPost(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.changeUserEmailUsersUserIdChangeEmailPost(userId, userSchemaChangeEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Change a user\'s password by ID.  This endpoint allows changing the password of an existing user.
         * @summary Change User Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPasswordUsersUserIdChangePasswordPost(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.changeUserPasswordUsersUserIdChangePasswordPost(userId, userSchemaChangePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.  This endpoint allows for the creation of a new user.
         * @summary Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.createUserUsersPost(userSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a user by ID.  This endpoint retrieves a user by their unique ID.
         * @summary Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIDUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.getUserByIDUsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of users.  This endpoint retrieves a paginated list of users based on provided filters.
         * @summary Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsersGet(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestUserSchemaBase> {
            return localVarFp.getUsersUsersGet(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Log in a user.  This endpoint allows a user to log in with the provided credentials.
         * @summary Login User
         * @param {UserSchemaLogin} userSchemaLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUserUsersLoginPost(userSchemaLogin: UserSchemaLogin, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.loginUserUsersLoginPost(userSchemaLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a user.  This endpoint registers a new user with the provided information.
         * @summary Register User
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUserUsersUserIdRegisterPost(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.registerUserUsersUserIdRegisterPost(userId, userSchemaRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user by ID.  This endpoint updates the details of an existing user.
         * @summary Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsersUserIdPut(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.updateUserUsersUserIdPut(userId, userSchemaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Change Email
         * @param {string} userId 
         * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChangeEmail(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1ChangeEmail(userId, userSchemaChangeEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Change Password
         * @param {string} userId 
         * @param {UserSchemaChangePassword} userSchemaChangePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChangePassword(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1ChangePassword(userId, userSchemaChangePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Check Register
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckRegister(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultRequest> {
            return localVarFp.v1CheckRegister(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Create User
         * @param {UserSchemaAdd} userSchemaAdd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateUser(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1CreateUser(userSchemaAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetMe(options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1GetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get Role By User Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetRoleByUserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.v1GetRoleByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get User By Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1GetUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Get Users
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string | null} [surname] 
         * @param {string | null} [name] 
         * @param {string | null} [email] 
         * @param {string | null} [emailNot] 
         * @param {string | null} [thirdPartyID] 
         * @param {string | null} [inviteCode] 
         * @param {number | null} [id] 
         * @param {string | null} [idIn] 
         * @param {number | null} [idNeq] 
         * @param {boolean | null} [isActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUsers(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginationRequestUserSchemaBase> {
            return localVarFp.v1GetUsers(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Register
         * @param {string} userId 
         * @param {UserSchemaRegister} userSchemaRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Register(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1Register(userId, userSchemaRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Users:Update User
         * @param {string} userId 
         * @param {UserSchemaUpdate} userSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateUser(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserSchemaBase> {
            return localVarFp.v1UpdateUser(userId, userSchemaUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Change a user\'s email by ID.  This endpoint allows changing the email of an existing user.
     * @summary Change User Email
     * @param {string} userId 
     * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserEmailUsersUserIdChangeEmailPost(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeUserEmailUsersUserIdChangeEmailPost(userId, userSchemaChangeEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change a user\'s password by ID.  This endpoint allows changing the password of an existing user.
     * @summary Change User Password
     * @param {string} userId 
     * @param {UserSchemaChangePassword} userSchemaChangePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserPasswordUsersUserIdChangePasswordPost(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeUserPasswordUsersUserIdChangePasswordPost(userId, userSchemaChangePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.  This endpoint allows for the creation of a new user.
     * @summary Create User
     * @param {UserSchemaAdd} userSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserUsersPost(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserUsersPost(userSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a user by ID.  This endpoint retrieves a user by their unique ID.
     * @summary Get User By Id
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByIDUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByIDUsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of users.  This endpoint retrieves a paginated list of users based on provided filters.
     * @summary Get Users
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string | null} [surname] 
     * @param {string | null} [name] 
     * @param {string | null} [email] 
     * @param {string | null} [emailNot] 
     * @param {string | null} [thirdPartyID] 
     * @param {string | null} [inviteCode] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {number | null} [idNeq] 
     * @param {boolean | null} [isActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersUsersGet(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUsersGet(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log in a user.  This endpoint allows a user to log in with the provided credentials.
     * @summary Login User
     * @param {UserSchemaLogin} userSchemaLogin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public loginUserUsersLoginPost(userSchemaLogin: UserSchemaLogin, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginUserUsersLoginPost(userSchemaLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a user.  This endpoint registers a new user with the provided information.
     * @summary Register User
     * @param {string} userId 
     * @param {UserSchemaRegister} userSchemaRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerUserUsersUserIdRegisterPost(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerUserUsersUserIdRegisterPost(userId, userSchemaRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user by ID.  This endpoint updates the details of an existing user.
     * @summary Update User
     * @param {string} userId 
     * @param {UserSchemaUpdate} userSchemaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserUsersUserIdPut(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserUsersUserIdPut(userId, userSchemaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Change Email
     * @param {string} userId 
     * @param {UserSchemaChangeEmail} userSchemaChangeEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1ChangeEmail(userId: string, userSchemaChangeEmail: UserSchemaChangeEmail, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1ChangeEmail(userId, userSchemaChangeEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Change Password
     * @param {string} userId 
     * @param {UserSchemaChangePassword} userSchemaChangePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1ChangePassword(userId: string, userSchemaChangePassword: UserSchemaChangePassword, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1ChangePassword(userId, userSchemaChangePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Check Register
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1CheckRegister(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1CheckRegister(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Create User
     * @param {UserSchemaAdd} userSchemaAdd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1CreateUser(userSchemaAdd: UserSchemaAdd, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1CreateUser(userSchemaAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1GetMe(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1GetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get Role By User Id
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1GetRoleByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1GetRoleByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get User By Id
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1GetUserById(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1GetUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Get Users
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string | null} [surname] 
     * @param {string | null} [name] 
     * @param {string | null} [email] 
     * @param {string | null} [emailNot] 
     * @param {string | null} [thirdPartyID] 
     * @param {string | null} [inviteCode] 
     * @param {number | null} [id] 
     * @param {string | null} [idIn] 
     * @param {number | null} [idNeq] 
     * @param {boolean | null} [isActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1GetUsers(page?: number, size?: number, surname?: string | null, name?: string | null, email?: string | null, emailNot?: string | null, thirdPartyID?: string | null, inviteCode?: string | null, id?: number | null, idIn?: string | null, idNeq?: number | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1GetUsers(page, size, surname, name, email, emailNot, thirdPartyID, inviteCode, id, idIn, idNeq, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Register
     * @param {string} userId 
     * @param {UserSchemaRegister} userSchemaRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1Register(userId: string, userSchemaRegister: UserSchemaRegister, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1Register(userId, userSchemaRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Users:Update User
     * @param {string} userId 
     * @param {UserSchemaUpdate} userSchemaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UpdateUser(userId: string, userSchemaUpdate: UserSchemaUpdate, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UpdateUser(userId, userSchemaUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



